function o=iss_options(o)
% o=iss_options(o)
% returns a structure o with options for in situ sequencing processing. 
% any options already in o will be left as-is; any missing will be filled with
% defaults.
%
% This structure will also store some metadata generated by programs. 
% 
% you need to run: 
% iss_extract_and_filter: makes top-hat-filtered images
% iss_register: registers within and between rounds
% iss_find_spots: detects spots and gets color vectors for them
% iss_call_spots: does crosstalk compensation and assigns each spot to a gene
% iss_single_genes: does the last round of single-probe detections
% iss_make_figure: makes a final figure as output
% 
% Kenneth D. Harris, 29/3/17
% GPL 3.0 https://www.gnu.org/licenses/gpl-3.0.en.html
 
if nargin<1
    o = struct;
end

% where the input czi files are kept
o = defopt(o, 'InputDirectory', 'A:\Dropbox\Dropbox (Neuropixels)\161230_161220KI_3-1');

% where the top-hat image files are kept (one for each tile and round, all channels)
o = defopt(o, 'TileDirectory', 'A:\Dropbox\Dropbox (Neuropixels)\161230_161220KI_3-1\FS_tophat_stack');

% where .mat file outputs and intermediates are kept
o = defopt(o, 'OutputDirectory', 'A:\Dropbox\Dropbox (Neuropixels)\161230_161220KI_3-1\results');

% which channel of each file is anchor images
o = defopt(o, 'AnchorChannel', 2);

% which sequencing round to align all others to
o = defopt(o, 'ReferenceRound', 2);

% how many sequencing rounds (not counting single-gene rounds)
o = defopt(o, 'nRounds', 5);

% one more round after the main rounds for Sst and Npy
o = defopt(o, 'nExtraRounds', 1); 
% For single-gene rounds, a n by 3 structure array of {GeneName, round, channel}
o = defopt(o, 'ExtraCodes', {'Npy', 6, 3; 'Sst', 6, 4});

% Number of possible basepairs (always 4 for life on earth)
o = defopt(o, 'nBP', 4);

% BasePair labels
o = defopt(o, 'bpLabels', 'TGCA');

% tile size (assumed square tiles)
o = defopt(o, 'TileSz', 2048);

% correlation threshold for image alignment. Can be low since chance
% correls are miniscule
o = defopt(o, 'CorrThresh', .2); 
% minimum size overlap for tile matching
o = defopt(o, 'MinSize', 100); 

% 1 to do point cloud registration
o = defopt(o, 'PointCloud', 1); 
% distance scale for point cloud registration (pixels)
o = defopt(o, 'PcDist', 3); 

% smooth images before detecting fluorescence with this radius:
o = defopt(o, 'SmoothSize', 1);

% thresholds for spot detection
o = defopt(o, 'DetectionThresh', 300);
o = defopt(o, 'IsolationThresh', 60);

o = defopt(o, 'Prctiles', [2 98]);
o = defopt(o, 'DetectionRadius', 1);
o = defopt(o, 'IsolationRadius1', 2);
o = defopt(o, 'IsolationRadius2', 7);

% for dapi images: scale is downsampling factor for final .fig file
o = defopt(o, 'DapiChannel', 1);
o = defopt(o, 'DapiScaleFac', 1);

% code file for spot calling
o = defopt(o, 'CodeFile', [o.InputDirectory '\codebook_unique.csv']);

% percentiles for normalizing spot codes
o = defopt(o, 'SpotNorm', [98 1]); 

% interactive graphics mode. 1 means some, 2 means a lot.
o = defopt(o, 'Graphics', 1);

% for segmentation
% percentile threshold for dapi image (after imadjust)
o = defopt(o, 'DapiThresh', 80);
% how close local maxima can be together (in pixels)
o = defopt(o, 'DapiMinSep', 7);
% how big cell radius needs to be to be detected (in pixels)
o = defopt(o, 'DapiMinSize', 5);
% how much margin around each cell to assign to it (in pixels)
o = defopt(o, 'DapiMargin', 10);
% minimum area in pixels for a cell not to be dropped
o = defopt(o, 'MinCellArea', 200);


return

% overwrite default options
function o=defopt(o, OptionName, Default)
    if ~isfield(o, OptionName)
        o.(OptionName) = Default;
    end
return